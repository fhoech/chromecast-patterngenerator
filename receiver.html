<!--
Copyright (C) 2014 Florian HÃ¶ch.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<!DOCTYPE html>
<html>
<head>
	<title>Chromecast Pattern Generator</title>
	<style type="text/css">
		html, body, #media {
			background-position: center;
			background-repeat: no-repeat;
			background-size: cover;
			height: 100%;
			margin: 0;
			overflow: hidden;
			padding: 0;
			width: 100%;
		}
		body {
			background-color: #292929;
		}
		#media {
			position: absolute;
		}
	</style>
	<script src="//www.gstatic.com/cast/sdk/libs/receiver/2.0.0/cast_receiver.js"></script>
	<script>
		window.onload = function () {
			var default_w = (window.width || document.body.offsetWidth) * .1,
				default_h = (window.width || document.body.offsetWidth) * .1,
				mediaElement = document.getElementById('media'),
				mediaManager = new cast.receiver.MediaManager(mediaElement),
				appConfig = new cast.receiver.CastReceiverManager.Config(),
				castReceiverManager = cast.receiver.CastReceiverManager.getInstance(),
				messageBus, imgdatachunks = {}, imgdatasize = {};

			function setPattern(which, data, sendLoadComplete) {
				var containerElement = which == 'background' ? document.body : mediaElement,
					img, imgdata, imgs = [];
				if (typeof(data) != 'string' ||
					data.indexOf('http:') === 0 ||
					data.indexOf('https:') === 0 ||
					data.indexOf('data:image') === 0 ||
					data.indexOf('size:') === 0 ||
					imgdatasize[which] > 0) {
					// Allow image URL for patterncolor and background color
					if (typeof(data) != 'string') {
						imgdatachunks[which] = ['data:', data.contentType || 'image/png',
												data.encoding ? ';' + data.encoding : '',
												','];
						imgdatasize[which] = imgdatachunks[which].join('').length + (parseInt(data.size) || data.data.length);
						imgdatachunks[which].push(data.data);
					}
					else if (data.indexOf('http:') === 0 ||
						data.indexOf('https:') === 0 ||
						data.indexOf('data:image') === 0) {
						imgdatasize[which] = data.length;
						imgdatachunks[which] = [data];
					}
					else if (data.indexOf('size:') === 0) {
						imgdatasize[which] = parseInt(data.split(':', 2)[1]);
						imgdatachunks[which] = [data.split(';').slice(1).join(';')];
					}
					else imgdatachunks[which].push(data);
					imgdata = imgdatachunks[which].join('');
					if (imgdata.length == imgdatasize[which]) {
						imgdatasize[which] = -1;
						img = new Image();
						img.onload = function () {
							this._containerElement.style.backgroundImage = 'url("' + this.src + '")';
							this._loaded = true;
							if (sendLoadComplete) {
								// Check if all images loaded
								for (var j = 0; j < imgs.length; j ++) if (!imgs[j]._loaded) break;
								if (j == imgs.length) mediaManager.sendLoadComplete();
							}
						}
						img._containerElement = containerElement;
						imgs.push(img);
						img.src = imgdata;
					}
				}
				else containerElement.style.backgroundColor = data;
				if (!imgs.length && sendLoadComplete) mediaManager.sendLoadComplete();
			}

			function setOffsetScale(ho, vo, ss, vs) {
				var x, y, w, h;
				if (ss) {
					w = Math.round(parseFloat(ss) * default_w);
					mediaElement.style.width = w + 'px';
				}
				if (vs || ss) {
					h = Math.round(parseFloat(vs || ss) * default_h);
					mediaElement.style.height = h + 'px';
				}
				if (ho != null) {
					x = parseFloat(ho) * ((window.width || document.body.offsetWidth) - mediaElement.offsetWidth);
					mediaElement.style.left = x + 'px';
				}
				if (vo != null) {
					y = parseFloat(vo) * ((window.height || document.body.offsetHeight) - mediaElement.offsetHeight);
					mediaElement.style.top = y + 'px';
				}
			}

			castReceiverManager.onReady = function (event) {
				castReceiverManager.setApplicationState('Ready');
			};

			messageBus = castReceiverManager.getCastMessageBus('urn:x-cast:net.hoech.cast.patterngenerator',
															   cast.receiver.CastMessageBus.MessageType.JSON);
			messageBus.onMessage = function (event) {
				/**
				 * Receive data via custom message bus.
				 *
				 * Actual data payload for the first (or only) message for each
				 * pattern should be
				 *
				 * {
				 *     "foreground": {
				 *         "contentType": "image/png",
				 *         "encoding": "base64",
				 *         "data": "<1st chunk of image data>",
				 *         "size": <size of whole image data in bytes>
				 *     },
				 *     "background": "rgb(<R>, <G>, <B>)",
				 *     "offset": [<offset_h>, <offset_v>],
				 *     "scale": [<scale_h>, <scale_v>]
				 * }
				 * 
				 * Keys other than "foreground" are optional.
				 * "foreground", "background" values can also be colors given
				 * as hex strings e.g. "#3C0" or RGB e.g. "rgb(51, 204, 0)".
				 * <offset_h>, <offset_v> should be given as relative position 0.0..1.0.
				 * <scale_h>, <scale_v> should be given as scaling factor 0.0..50.0.
				 *
				 * In case of data URLs, the payload may need to be split
				 * to stay within the 64K transport message size limit
				 * (see https://developers.google.com/cast/docs/reference/messages).
				 *
				 * To accomodate this, the first message must indicate
				 * the size of the whole image data string in bytes as above,
				 * and subsequent messages should just contain chunks of the
				 * remaining data. E.g.
				 *
				 * {
				 *     "foreground": "<nth chunk of image data>"
				 * }
				 *
				 **/
				var data = event.data;
				console.log(event.senderId, typeof(event.data));
				if (data.scale) setOffsetScale(null, null, data.scale[0], data.scale[1]);
				if (data.offset) setOffsetScale(data.offset[0], data.offset[1])
				if (data.foreground) setPattern('foreground', data.foreground);
				if (data.background) setPattern('background', data.background);
				messageBus.send(event.senderId, 'ACK');
			};

			mediaManager.onLoad = function (event) {
				var data, items;
				if (event.data['media'] && (event.data['media']['contentId'] || event.data['media']['customData'])) {
					/**
					 * NOTE that receiving data via the LOAD command is just
					 * available for backwards compatibility. The recommended
					 * way is to use the custom message bus.
					 *
					 * Data must be an image URL or a string in the form:
					 * "<foreground>|<background>|<offset_h>|<offset_v>|<scale_h>|<scale_v>"
					 * Values other than <foreground> are optional.
					 * <foreground>, <background> can be colors given as hex
					 * strings e.g. "#3C0", RGB e.g. "rgb(51, 204, 0)", or
					 * image URLs.
					 * <offset_h>, <offset_v> should be given as relative position 0.0..1.0.
					 * <scale_h>, <scale_v> should be given as scaling factor 0.0..50.0.
					 *
					 * In case of data URLs, the payload may need to be split
					 * to stay within the 64K transport message size limit
					 * (see https://developers.google.com/cast/docs/reference/messages).
					 *
					 * To accomodate this, the first message must indicate
					 * the size of the whole data string in bytes (i.e.
					 * including "data:image"), and subsequent messages should
					 * just contain chunks of the remaining data. E.g.
					 *
					 * 1st message: "size:128000;data:image/png;base64,<first chunk of image data>"
					 * 2nd message: "<second chunk of image data>"
					 * Etc.
					 */
					if (event.data['media']['customData'])
						data = event.data['media']['customData'];
					else
						data = event.data['media']['contentId'];
					if (typeof(data) == 'string') {
						items = data.split('|');
						setOffsetScale(items[2], items[3], items[4], items[5]);
						for (var i = 0; i < 2; i ++) if (items[i]) setPattern(i ? 'background' : 'foreground', items[i], true);
					}
					else messageBus.onMessage(event);
				}
				else this.sendLoadError();
			};

			/**
			 * Text that represents the application status. It should meet
			 * internationalization rules as may be displayed by the sender application.
			 * @type {string|undefined}
			 **/
			appConfig.statusText = 'Starting...';

			/**
			* Maximum time in seconds before closing an idle
			* sender connection. Setting this value enables a heartbeat message to keep
			* the connection alive. Used to detect unresponsive senders faster than
			* typical TCP timeouts. The minimum value is 5 seconds, there is no upper
			* bound enforced but practically it's minutes before platform TCP timeouts
			* come into play. Default value is 10 seconds.
			* @type {number|undefined}
			**/
			appConfig.maxInactivity = 10;

			castReceiverManager.start(appConfig);

			// Useful to have these available globally for debugging
			window.mediaManager = mediaManager;
			window.castReceiverManager = castReceiverManager;
		};
	</script>
</head>
<body>
	<video id="media"></video>
</body>
</html>