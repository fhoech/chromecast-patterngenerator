<!DOCTYPE html>
<html>
<head>
	<title>Chromecast Pattern Generator</title>
	<style type="text/css">
		html, body, #media {
			background-position: center;
			background-repeat: no-repeat;
			background-size: cover;
			height: 100%;
			margin: 0;
			overflow: hidden;
			padding: 0;
			width: 100%;
		}
		body {
			background-color: #292929;
		}
		#media {
			position: absolute;
		}
	</style>
	<script src="//www.gstatic.com/cast/sdk/libs/receiver/2.0.0/cast_receiver.js"></script>
	<script>
		window.onload = function () {
			var mediaElement = document.getElementById('media'),
				mediaManager = new cast.receiver.MediaManager(mediaElement),
				appConfig = new cast.receiver.CastReceiverManager.Config(),
				castReceiverManager = cast.receiver.CastReceiverManager.getInstance();

			mediaManager.onLoad = function (event) {
				var contentId, items, containerElement, img, imgs = [],
					default_w = (window.width || document.body.offsetWidth) * (256 / 1920),
					default_h = (window.width || document.body.offsetWidth) * (256 / 1920),
					x, y, w, h;
				if (event.data['media'] && event.data['media']['contentId']) {
					/**
					 * contentId must be an image URL or a string in the form:
					 * "<foreground>|<background>|<x>|<y>|<width>|<height>"
					 * Values other than <foreground> are optional.
					 * <foreground>, <background> can be hex strings e.g. "#3C0", RGB e.g. "rgb(51, 204, 0)", or image URLs.
					 * <x>, <y> should be given as relative position 0.0..1.0.
					 * <width>, <height> should be given as scaling factor 0.0..50.0.
					 */
					contentId = event.data['media']['contentId'];
					items = contentId.split('|');
					for (var i = 0; i < 2; i ++) {
						if (!items[i]) continue;
						containerElement = i == 0 ? mediaElement : document.body;
						if (items[i].indexOf('http') === 0 || items[i].indexOf('data:image') === 0) {
							// Allow image URL for patterncolor and background color
							img = new Image();
							img.onload = function () {
								this._containerElement.style.backgroundImage = 'url("' + this.src + '")';
								this._loaded = true;
								// Check if all images loaded
								for (var j = 0; j < imgs.length; j ++) if (!imgs[j]._loaded) break;
								if (j == imgs.length) mediaManager.sendLoadComplete();
							}
							img._containerElement = containerElement;
							imgs.push(img);
							img.src = items[i];
						}
						else containerElement.style.backgroundColor = items[i];
					}
					if (items[4]) {
						w = parseFloat(items[4]) * default_w;
						mediaElement.style.width = w + 'px';
					}
					if (items[5] || items[4]) {
						h = parseFloat(items[5] || items[4]) * default_h;
						mediaElement.style.height = h + 'px';
					}
					if (items[2]) {
						x = parseFloat(items[2]) * ((window.width || document.body.offsetWidth) - mediaElement.offsetWidth);
						mediaElement.style.left = x + 'px';
					}
					if (items[3]) {
						y = parseFloat(items[3]) * ((window.height || document.body.offsetHeight) - mediaElement.offsetHeight);
						mediaElement.style.top = y + 'px';
					}
					if (!imgs.length) mediaManager.sendLoadComplete();
				}
				else this.sendLoadError();
			};

			/**
			 * Text that represents the application status. It should meet
			 * internationalization rules as may be displayed by the sender application.
			 * @type {string|undefined}
			 **/
			appConfig.statusText = 'Ready';

			/**
			* Maximum time in seconds before closing an idle
			* sender connection. Setting this value enables a heartbeat message to keep
			* the connection alive. Used to detect unresponsive senders faster than
			* typical TCP timeouts. The minimum value is 5 seconds, there is no upper
			* bound enforced but practically it's minutes before platform TCP timeouts
			* come into play. Default value is 10 seconds.
			* @type {number|undefined}
			**/
			appConfig.maxInactivity = 10;

			castReceiverManager.start(appConfig);

			// Useful to have these available globally for debugging
			window.mediaManager = mediaManager;
			window.castReceiverManager = castReceiverManager;
		};
	</script>
</head>
<body>
	<video id="media"></video>
</body>
</html>