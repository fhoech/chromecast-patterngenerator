<!DOCTYPE html>
<html>
<head>
	<title>Chromecast Pattern Generator</title>
	<style type="text/css">
		html, body {
			background: #000;
			height: 100%;
			margin: 0;
			overflow: hidden;
			padding: 0;
			width: 100%;
		}
		#media {
			background: #808080;
			height: 300px;
			left: 50%;
			margin-left: -150px;
			margin-top: -150px;
			position: absolute;
			top: 50%;
			width: 300px;
		}
	</style>
	<script src="//www.gstatic.com/cast/sdk/libs/receiver/2.0.0/cast_receiver.js"></script>
	<script>
		window.onload = function () {
			var mediaElement = document.getElementById('media'),
				mediaManager = new cast.receiver.MediaManager(mediaElement),
				appConfig = new cast.receiver.CastReceiverManager.Config(),
				castReceiverManager = cast.receiver.CastReceiverManager.getInstance();

			mediaManager.onLoad = function (event) {
				var contentId, img;
				if (event.data['media'] && event.data['media']['contentId']) {
					/**
					 * contentId must be an image URL or a string in the form:
					 * "<patterncolor>;<backgroundcolor>;<x>;<y>;<width>;<height>"
					 * Values other than patterncolor are optional.
					 * Colors can be hex strings e.g. "#3C0" or RGB e.g. "rgb(51, 204, 0)"
					 * x, y, width and height should be given in pixels.
					 */
					contentId = event.data['media']['contentId'];
					if (contentId.indexOf('http') === 0 || contentId.indexOf('data:image/png') === 0) {
						// Image
						img = new Image();
						img.onload = function () {
							document.body.style.background = '#000 url(' + contentId + ') no-repeat center';
							mediaElement.style.display = 'none';
							mediaManager.sendLoadComplete();
						}
						img.src = contentId + '?' + new Date().getTime();
					}
					else {
						// Colors, position and size
						items = contentId.split(';');
						mediaElement.style.backgroundColor = items[0];
						if (items[1])
							document.body.style.background = items[1];
						if (items[2])
							mediaElement.style.left = items[2] + 'px';
						if (items[3])
							mediaElement.style.top = items[3] + 'px';
						if (items[4]) {
							mediaElement.style.width = items[4] + 'px';
							mediaElement.style.marginLeft = -parseFloat(items[4]) / 2 + 'px';
						}
						if (items[5]) {
							mediaElement.style.height = items[5] + 'px';
							mediaElement.style.marginTop = -parseFloat(items[5]) / 2 + 'px';
						}
						mediaElement.style.display = 'block';
						this.sendLoadComplete();
					}
				}
				else this.sendLoadError();
			};

			/**
			 * Text that represents the application status. It should meet
			 * internationalization rules as may be displayed by the sender application.
			 * @type {string|undefined}
			 **/
			appConfig.statusText = 'Ready';

			/**
			* Maximum time in seconds before closing an idle
			* sender connection. Setting this value enables a heartbeat message to keep
			* the connection alive. Used to detect unresponsive senders faster than
			* typical TCP timeouts. The minimum value is 5 seconds, there is no upper
			* bound enforced but practically it's minutes before platform TCP timeouts
			* come into play. Default value is 10 seconds.
			* @type {number|undefined}
			**/
			appConfig.maxInactivity = 10;

			castReceiverManager.start(appConfig);
		};
	</script>
</head>
<body>
	<video id="media"></video>
</body>
</html>