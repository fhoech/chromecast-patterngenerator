<!--
Copyright (C) 2014 Florian HÃ¶ch.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<!DOCTYPE html>
<html>
<head>
	<title>Chromecast Pattern Generator</title>
	<style type="text/css">
		html, body, #media {
			background-position: center;
			background-repeat: no-repeat;
			background-size: cover;
			height: 100%;
			margin: 0;
			overflow: hidden;
			padding: 0;
			width: 100%;
		}
		body {
			background-color: #292929;
		}
		#media {
			position: absolute;
		}
	</style>
	<script src="//www.gstatic.com/cast/sdk/libs/receiver/2.0.0/cast_receiver.js"></script>
	<script>
		window.onload = function () {
			var default_w = (window.width || document.body.offsetWidth) * (256 / 1920),
				default_h = (window.width || document.body.offsetWidth) * (256 / 1920),
				mediaElement = document.getElementById('media'),
				mediaManager = new cast.receiver.MediaManager(mediaElement),
				appConfig = new cast.receiver.CastReceiverManager.Config(),
				castReceiverManager = cast.receiver.CastReceiverManager.getInstance(),
				messageBus, imgdatachunks = {}, imgdatasize = {};

			function setPattern(which, data, sendLoadComplete) {
				var containerElement = which == 'background' ? document.body : mediaElement,
					img, imgdata, imgs = [];
				if (typeof(data) != 'string' ||
					data.indexOf('http:') === 0 ||
					data.indexOf('https:') === 0 ||
					data.indexOf('data:image') === 0 ||
					data.indexOf('size:') === 0 ||
					imgdatasize[which] > 0) {
					// Allow image URL for patterncolor and background color
					if (typeof(data) != 'string') {
						imgdatachunks[which] = ['data:', data.contentType || 'image/png',
												data.encoding ? ';' + data.encoding : '',
												','];
						imgdatasize[which] = imgdatachunks[which].join('').length + (parseInt(data.size) || data.data.length);
						imgdatachunks[which].push(data.data);
					}
					else if (data.indexOf('http:') === 0 ||
						data.indexOf('https:') === 0 ||
						data.indexOf('data:image') === 0) {
						imgdatasize[which] = data.length;
						imgdatachunks[which] = [data];
					}
					else if (data.indexOf('size:') === 0) {
						imgdatasize[which] = parseInt(data.split(':', 2)[1]);
						imgdatachunks[which] = [data.split(';').slice(1).join(';')];
					}
					else imgdatachunks[which].push(data);
					imgdata = imgdatachunks[which].join('');
					if (imgdata.length == imgdatasize[which]) {
						imgdatasize[which] = -1;
						img = new Image();
						img.onload = function () {
							this._containerElement.style.backgroundImage = 'url("' + this.src + '")';
							this._loaded = true;
							if (sendLoadComplete) {
								// Check if all images loaded
								for (var j = 0; j < imgs.length; j ++) if (!imgs[j]._loaded) break;
								if (j == imgs.length) mediaManager.sendLoadComplete();
							}
						}
						img._containerElement = containerElement;
						imgs.push(img);
						img.src = imgdata;
					}
				}
				else containerElement.style.backgroundColor = data;
				if (!imgs.length && sendLoadComplete) mediaManager.sendLoadComplete();
			}

			function setOffsetScale(ho, vo, ss, vs) {
				var x, y, w, h;
				if (ss) {
					w = parseFloat(ss) * default_w;
					mediaElement.style.width = w + 'px';
				}
				if (vs || ss) {
					h = parseFloat(vs || ss) * default_h;
					mediaElement.style.height = h + 'px';
				}
				if (ho != null) {
					x = parseFloat(ho) * ((window.width || document.body.offsetWidth) - mediaElement.offsetWidth);
					mediaElement.style.left = x + 'px';
				}
				if (vo != null) {
					y = parseFloat(vo) * ((window.height || document.body.offsetHeight) - mediaElement.offsetHeight);
					mediaElement.style.top = y + 'px';
				}
			}

			castReceiverManager.onReady = function (event) {
				castReceiverManager.setApplicationState('Ready');
			};

			messageBus = castReceiverManager.getCastMessageBus('urn:x-cast:net.hoech.cast.patterngenerator');
			messageBus.onMessage = function (event) {
				var data = event.data;
				console.log(event);
				if (data.scale) setOffsetScale(null, null, data.scale[0], data.scale[1]);
				if (data.offset) setOffsetScale(data.offset[0], data.offset[1])
				if (data.foreground) setPattern('foreground', data.foreground);
				if (data.background) setPattern('background', data.background);
				messageBus.send(event.senderId, 'ACK');
			};

			mediaManager.onLoad = function (event) {
				var data, items;
				if (event.data['media'] && (event.data['media']['contentId'] || event.data['media']['customData'])) {
					/**
					 * Data must be an image URL or a string in the form:
					 * "<foreground>|<background>|<x>|<y>|<width>|<height>"
					 * Values other than <foreground> are optional.
					 * <foreground>, <background> can be hex strings e.g. "#3C0", RGB e.g. "rgb(51, 204, 0)", or image URLs.
					 * <x>, <y> should be given as relative position 0.0..1.0.
					 * <width>, <height> should be given as scaling factor 0.0..50.0.
					 *
					 * In case of data URLs, the payload may need to be split
					 * to stay within the 64K transport message size limit
					 * (see https://developers.google.com/cast/docs/reference/messages).
					 *
					 * To accomodate this, the first message must indicate
					 * the size of the whole data string in bytes (i.e.
					 * including "data:image"), and subsequent messages should
					 * just contain chunks of the remaining data. E.g.
					 *
					 * 1st message: "size:128000;data:image/png;base64,<first chunk of image data>"
					 * 2nd message: "<second chunk of image data>"
					 * Etc.
					 */
					if (event.data['media']['customData'])
						data = event.data['media']['customData'];
					else
						data = event.data['media']['contentId'];
					if (typeof(data) == 'string') {
						items = data.split('|');
						setOffsetScale(items[2], items[3], items[4], items[5]);
						for (var i = 0; i < 2; i ++) if (items[i]) setPattern(i ? 'background' : 'foreground', items[i], true);
					}
					else messageBus.onMessage(event);
				}
				else this.sendLoadError();
			};

			/**
			 * Text that represents the application status. It should meet
			 * internationalization rules as may be displayed by the sender application.
			 * @type {string|undefined}
			 **/
			appConfig.statusText = 'Starting...';

			/**
			* Maximum time in seconds before closing an idle
			* sender connection. Setting this value enables a heartbeat message to keep
			* the connection alive. Used to detect unresponsive senders faster than
			* typical TCP timeouts. The minimum value is 5 seconds, there is no upper
			* bound enforced but practically it's minutes before platform TCP timeouts
			* come into play. Default value is 10 seconds.
			* @type {number|undefined}
			**/
			appConfig.maxInactivity = 10;

			castReceiverManager.start(appConfig);

			// Useful to have these available globally for debugging
			window.mediaManager = mediaManager;
			window.castReceiverManager = castReceiverManager;
		};
	</script>
</head>
<body>
	<video id="media"></video>
</body>
</html>